import os
import shutil

import snippets
from constants import DUX_MAIN_FILE, DUX_ACTIONS_FILE

templates_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), '../templates')

get_template_path = os.path.join$(templates_dir)

def cleaner(f):
    def wrapped(name, *args, **kwargs):
        try:
            return f(name, *args, **kwargs)
        except Exception as e:
            shutil.rmtree(name)
            raise e
    return wrapped

def get_template_text(template) = open(get_template_path(template)).read()

def write_template(path, template, values, config):
    context = snippets.get_snippets_for_template(template, path, values, config) 
    if not os.path.exists(os.path.dirname(path)):
        os.makedirs(os.path.dirname(path))
    with open(path, 'w') as f:
        (template 
            |> get_template_path 
            |> open 
            |> ((t) -> t.read().format(**context))
            |> f.write)


def last_of(pred, lines):
    def aux(n, (i, line)) = i if pred(line) else n

    return reduce(aux, lines |> enumerate, 0)


def insert_after(payload, xs, n):
    def aux((acc, n), line) = ( 
        acc + [line] + ([payload] if n == 0 else []), n - 1
        )
    [acc, _] = reduce(aux, xs, ([], n))
    return acc


def insert_after_last_occurence_of(pred, values, lines) = (
    lines
    |> last_of$(pred)
    |> insert_after$(values, lines))


def update_includes(filename, new_import, new_line, pattern="export default"):
    print(filename)
    print(os.getcwd())
    lines = open(filename).readlines()
    
    if map((line) -> new_line in line, lines) |> any:
        "%s already includes '%s'" % (filename, new_line) |> print
        return 

    with_import = (lines 
            |> insert_after_last_occurence_of$(
                (line) -> "import" in line, new_import)
    )

    with_new_line = (with_import 
        |> insert_after_last_occurence_of$(
            (line) -> pattern in line,
            new_line)
    )

    (with_new_line
        |> open(filename, "w").writelines)


def add_action_import(action_file, new_action):
    with open(action_file, 'a') as f:
        f.write("\nexport * from './%s'" % new_action)

def update_dux_imports(new_file, values, config):
    dux_dir = get_partial_path(new_file, up_to="dux")
    main_file = os.path.join(dux_dir, DUX_MAIN_FILE)
    action_file = os.path.join(dux_dir, DUX_ACTIONS_FILE)
    dux_import = snippets.get_snippet('s_dux_import', values, config)
    dux_reducer = snippets.get_snippet('s_dux_reducer_new_line', values, config)
    update_includes(main_file, dux_import, dux_reducer)
    add_action_import(action_file, values["name"])
     
def get_partial_path(path, up_to):
    dirs = path.split("/")
    return os.path.join(*dirs[:dirs.index(up_to) + 1])

def find_path(from_file, to_file, root="src"):
    from_dir = os.path.dirname(relative_path(from_file, root))
    path_to_to_file = relative_path(to_file, root)
    return os.path.relpath(path_to_to_file, from_dir)

def relative_path(name, root="src"):
    base = os.path.basename(name)
    dir = os.path.dirname(name).strip('./')

    for dirpath, dirnames, filenames in os.walk(os.path.join(find_root(root), root)):
        matching_file = first_matching(filenames, base)
        if matching_file and dir in dirpath:
            return os.path.join(dirpath, matching_file)


def get_store_to_module_path(parser, values):
    if parser.cmd != "start":
        return None
    dux = os.path.join(values["module_path"], "state/dux")
    return os.path.relpath(dux, parser.config["store_dir"])


def first_matching(xs, x):
    for s in xs: 
        if x in s:
            return s


def find_path_in_tree(file_name, path="."):
    file_path = os.path.join(path, file_name)
    if os.path.exists(file_path):
        return file_path
    elif os.path.samefile(path, '/'):
        raise ValueError('Cannot find {} in current file tree'.format(file_name))
    else:
        return find_path_in_tree(file_name, os.path.join(path, '..'))


@recursive
def find_root(root, path="./") = (
    path if root in os.listdir(path) else find_root(root, os.path.join("..", path))
    )

def touch(path):
    with open(path, 'a'):
        os.utime(path)

def get_dux_file_path(name) = name.replace(".", "/")

def get_module(parser):
    if parser.module_name:
        return parser.module_name
    if parser.cmd == "comp":
        return None
    else:
        return input("> What module will this be part of? ")

def get_values_dict(parser):
    values = dict(parser.config)
    values["name"] = parser.name
    values["new_dux_file_path"] = get_dux_file_path(parser.name)
    values["store_type_path"] = parser.config.get("store_flow_file", os.path.join(parser.config["store_dir"], "types.js"))
    values["cap_name"] = parser.name[0].capitalize() + parser.name[1:]
    values["module_full"] = parser.name if parser.cmd in ["start", "comp"] else get_module(parser).replace(".", "/")
    values["module_name"] = values["module_full"].split("/")[-1]
    values["module_type"] = "$" + values["module_name"][0].capitalize() + values["module_name"][1:]
    values["module_path"] = "./%s" % values["module_name"] if parser.cmd in ["start", "comp"] else find_path_in_tree(values["module_full"])
    values["store_to_module_path"] = get_store_to_module_path(parser, values)
    return values 
